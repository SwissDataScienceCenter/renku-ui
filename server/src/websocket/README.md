# WebSocket

WebSocket allows the UI server to push notifications directly to the UI client through a
bi-directional communication channel after an initial setup that helps in identifying the
user.

This way, we can remove inefficient polling systems to keep an up-to-date status of some
resources. In the first iteration, this will be limited to moving the polling logic from the
client to the server with little changes. Ideally, we will later rely more on server events
generated by the backend services, removing polling entirely.

WebSocket also simplifies notifications. We already have a raw system for that in the client,
and after updating it, we could use it more extensively and ensure the content shown on all
pages won't become stale without notifying the user.

## Why WebSocket?

There aren't many well-established technologies to create a channel allowing the server to
send data to the client. The final choice between
[WebSocket](https://en.wikipedia.org/wiki/WebSocket) and
[Server-sent events](https://en.wikipedia.org/wiki/Server-sent_events) has seen the first
prevail since it also enables the client to send messages to the server.
Those can be used as commands to subscribe and unsubscribe to specific events based on the
resources the user wants to access.

## Authentication

The authentication can only be done while establishing the connection. This is not a big
deal for the UI server, considering it manages the access tokens on behalf of the users.
At each cycle/request, we can verify whether the tokens are still valid or not, and either
proceed or send an error message and close the channel.

# Overview

This is the current set of interactions between the client and the server.

Notice that, after an initialy authentication phase, there are two loops repeated approximatly
every 5 seconds (short loop) and every 3 minutes (long loop).

```mermaid
sequenceDiagram
  par Bootstrap phase
    client->>server: Initialization
    server-->>Keycloak: Identify user
    server->>server: Set up channel
    server->>client: Ack / Error
  end
  server->>server:Loop every N seconds
  par Short loop
    server-->>Keycloak: Ensure token validity
    server->>backend services: Check sessions
    server->>client: Send message (if necessary)
  end
  par Long loop
    server-->>Keycloak: Ensure token validity
    server->>server: Check UI version
    server->>client: Send message (if necessary)
  end
```

The client can send messages interpreted as instructions by the server.

The following is just an example:

```mermaid
sequenceDiagram
  par Subscribe to events
    client->>server: subscribe to /project/<id>/<eventType>
    server->>GitLab: subscribe to SSE for /project/<id>/<eventType>
  end
  GitLab->>server: send event notification
  server->>client: notify client (if needed)
  GitLab->>server: send event notification
  server->>client: notify client (if needed)
  par Unsubscribe to events
    client->>server: unsubscribe from /project/<id>/<eventType>
    server->>GitLab: update SSE for /project/<id>
  end
```

## Extend the supported commands

The list of supported commands can be found in the [WebSocket index file](/index.ts)
looking at the `acceptedMessages` variable.

It can be easily extended by adding a new command with a set of:

* Mandatory parameters.
* Optional parameters.
* A single handler function.

Additional handlers can be added to either the `longLoopFunctions` or
`shortLoopFunctions` variables.

Ideally, for each supported command, there should be a handler function for the
setup phase and a loop function repeated for each iteration of the relevant loop.
Any relevant data is currently cached locally, but Redis support can easily be
added if we require it.


## Handle multiple tabs/sessions

Since each loop sends requests to back-end services on behalf of the user, we want to limit them
to the minimum. This requires a strategy to handle multiple tabs in a single loop.
WebSocket channels are handled per user, and each time a new channel is added, the
server sends the same notification to each of them. When the last user's channel is removed,
the loop stops.
